
# 抽象类，抽象方法

【1】抽象类和抽象方法的关系： 

抽象类中可以定义0-n个抽象方法。 

【2】抽象类作用： 

在抽象类中定义抽象方法，目的是为了为子类提供一个通用的模板，子类可以在模板的基础上进行开发，先重写父类的抽象方法，然后可以扩展子类自己的内容。抽象类设计避免了子类设计的随意性，通过抽象类，子类的设计变得更加严格，进行某些程度上的限制。 

使子类更加的通用。 




【3】代码： 




1.  package com.msb.test03;
2.  //4.一个类中如果有方法是抽象方法，那么这个类也要变成一个抽象类。
3.  //5.一个抽象类中可以有0-n个抽象方法
4.  public abstract class Person {
5.      //1.在一个类中，会有一类方法，子类对这个方法非常满意，无需重写，直接使用
6.      public void eat(){
7.          System.out.println("一顿不吃饿得慌");
8.      }
9.      //2.在一个类中，会有一类方法，子类对这个方法永远不满意，会对这个方法进行重写。
10.     //3.一个方法的方法体去掉，然后被abstract修饰，那么这个方法就变成了一个抽象方法
11.     public abstract void say();
12.     public abstract void sleep();
13. }
14. //6.抽象类可以被其他类继承：
15. //7.一个类继承一个抽象类，那么这个类可以变成抽象类
16. //8.一般子类不会加abstract修饰，一般会让子类重写父类中的抽象方法
17. //9.子类继承抽象类，就必须重写全部的抽象方法
18. //10.子类如果没有重写父类全部的抽象方法，那么子类也可以变成一个抽象类。
19. class Student extends Person{
20.     @Override
21.     public void say() {
22.         System.out.println("我是东北人，我喜欢说东北话。。");
23.     }
24.     @Override
25.     public void sleep() {
26.         System.out.println("东北人喜欢睡炕。。");
27.     }
28. }
29. class Demo{
30.     //这是一个main方法，是程序的入口：
31.     public static void main(String[] args) {
32.         //11.创建抽象类的对象：-->抽象类不可以创建对象
33.         //Person p = new Person();
34.         //12.创建子类对象：
35.         Student s = new Student();
36.         s.sleep();
37.         s.say();
38.         
39.         //13.多态的写法：父类引用只想子类对象：
40.         Person p  = new Student();
41.         p.say();
42.         p.sleep();
43.     }
44. }

 

【4】面试题： 

（1）抽象类不能创建对象，那么抽象类中是否有构造器？ 

抽象类中一定有构造器。构造器的作用  给子类初始化对象的时候要先super调用父类的构造器。 




（2）抽象类是否可以被final修饰？ 

不能被final修饰，因为抽象类设计的初衷就是给子类继承用的。要是被final修饰了这个抽象类了，就不存在继承了，就没有子类。 


















------------------------------------------------------------

